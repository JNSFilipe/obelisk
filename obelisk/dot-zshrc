# Automatically attach or create a tmux session named "main"
# with an exception for VS Code terminals
if command -v tmux &> /dev/null && [ -z "$TMUX" ] && [ "$TERM_PROGRAM" != "vscode" ]; then
  tmux attach-session -t main || tmux new-session -s main
fi

# Setup zsh history
HISTFILE=~/.zsh_history
HISTSIZE=10000000
SAVEHIST=$HISTSIZE
HISTDUP=erase # Erase duplicates in history
setopt interactive_comments # https://github.com/marlonrichert/zsh-autocomplete/issues/726
setopt appendhistory
setopt sharehistory # Share history between running sessions
setopt hist_ignore_all_dups # Ignore all duplicates in history
setopt hist_save_no_dups # Do not save duplicates in history
setopt hist_ignore_dups # Ignore duplicates in history

# Path and Variables
PATH=$PATH:~/.local/bin
PATH=$PATH:~/.cargo/bin
PATH=$PATH:~/.config/scripts
PATH=$PATH:/usr/local/bin
PATH=$PATH:/opt/homebrew/bin
PATH=$PATH:/opt/homebrew/sbin
if [[ $(uname) == "Darwin" ]]; then # Check if macOS
    # In macOS, we have to rebuild almost the entire PATH
    # https://wezfurlong.org/wezterm/faq.html#im-on-macos-and-wezterm-cannot-find-things-in-my-path
    PATH=$PATH:/System/Cryptexes/App/usr/bin
    PATH=$PATH:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin
    PATH=$PATH:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin
    PATH=$PATH:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin
    PATH=$PATH:/Library/TeX/texbin
fi

# Load/install znap
[[ -r ~/.znap/znap/znap.zsh ]] ||
    git clone --depth 1 -- \
        https://github.com/marlonrichert/zsh-snap.git ~/.znap/znap
source ~/.znap/znap/znap.zsh  # Start Znap

# Start compinit
autoload -Uz compinit # https://unix.stackexchange.com/questions/339954/zsh-command-not-found-compinstall-compinit-compdef
compinit

# fzf autocompletion
znap source Aloxaf/fzf-tab

# Fish like gohst autocompletion
znap source marlonrichert/zsh-autocomplete

# Better zsh autocompletion
znap source zsh-users/zsh-autosuggestions

# Better zsh history search
znap source atuinsh/atuin

# Use pure pormpt if starship not installed; starship otherwise
# if ! type "starship" > /dev/null; then
#     # Starshipt not installed; install and setup pure prompt
#     # Install and setup pure prompt
#     fpath+=($HOME/.znap/sindresorhus/pure) # Load necessary functions (this wont work on first install)
#     znap source sindresorhus/pure # Pull the repository from github
#     autoload -U promptinit; promptinit # Recommended on README
#     zstyle :prompt:pure:prompt:success color green
#     zstyle :prompt:pure:prompt:error color red
#     zstyle :prompt:pure:git:stash show yes
#     prompt pure # Recommended on README
# else
#     # Starshipt installed; Setup starship
#     eval "$(starship init zsh)"
# fi

fpath+=($HOME/.znap/sindresorhus/pure) # Load necessary functions (this wont work on first install)
znap source sindresorhus/pure # Pull the repository from github
autoload -U promptinit; promptinit # Recommended on README
zstyle :prompt:pure:prompt:success color green
zstyle :prompt:pure:prompt:error color red
zstyle :prompt:pure:git:stash show yes
prompt pure # Recommended on README

# fzf integration
# source <(fzf --zsh)
# zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza --icons $realpath'

# Setup zoxide
eval "$(zoxide init zsh)"

# If not within tmux, bind ctrl+Space to session starter
if [ -z "$TMUX" ]; then
    bindkey -s "^ " "zzz\n"
fi

# Alias
alias cd='z'
alias ls='eza --icons'
alias la='eza --icons -A'
alias ll='eza --icons -al'
alias lsg='eza --icons -D'
alias lag='eza --icons -AD'
alias llg='eza --icons -alD'
alias ww='wget'
alias vi='nvim'
alias vim='nvim'
alias del='sudo rm -r'
alias comp='sudo make install'
alias gl='git clone'
alias lg='lazygit'
alias rcp='rsync -avzh --progress --stats'
alias spartan='emacs --init-dir $HOME/.config/spartan'

# Source OCaml
# opam configuration
[[ ! -r ~/.opam/opam-init/init.zsh ]] || source ~/.opam/opam-init/init.zsh  > /dev/null 2> /dev/null

# [ ! -f "$HOME/.x-cmd.root/X" ] || . "$HOME/.x-cmd.root/X" # boot up x-cmd.
export PATH="$PATH:"/Applications/microchip/xc8/v3.00/bin""

# Function to find and activate a Python virtual environment
activate() {
    # If there is a currently active environment, deactivate it
    if [ -n "$VIRTUAL_ENV" ]; then
        deactivate
    fi

    # Check for common virtual environment directory names
    venv_dirs=("venv" ".venv" "env" ".env" "virtualenv")

    for dir in "${venv_dirs[@]}"; do
        # Check if the virtual environment directory exists
        if [ -d "$dir" ] && [ -f "$dir/bin/activate" ]; then
            echo "Activating virtual environment in $dir"
            source "$dir/bin/activate"
            return 0
        fi
    done

    # If no virtual environment is found
    echo "No Python virtual environment found in the current directory."
    return 1
}

# Define the em function to launch emacs
em() {
    # Attempt to activate a virtual environment
    if activate; then
        # If activated successfully, check if python-lsp-server is installed
        if ! uv pip show python-lsp-server &>/dev/null; then
            echo "python-lsp-server not found. Installing..."
            uv add "python-lsp-server[pyflakes]" # Add pep8 to style linting
        fi
        # Now run emacs within the environment
        emacs -nw "$@"
    else
        # If no environment is found, just run emacs
        emacs -nw "$@"
    fi
}

# Define the dem function to launch vanilla emacs
vem() {
    # Attempt to activate a virtual environment
    if activate; then
        # If activated successfully, check if python-lsp-server is installed
        if ! uv pip show python-lsp-server &>/dev/null; then
            echo "python-lsp-server not found. Installing..."
            uv add "python-lsp-server[pyflakes]" # Add pep8 to style linting
        fi
        # Now run emacs within the environment
        emacs --init-dir $HOME/.config/vemacs -nw "$@"
    else
        # If no environment is found, just run emacs
        emacs --init-dir $HOME/.config/vemacs -nw "$@"
    fi
}

# Define the essh function to launch GUI Emacs with TRAMP for remote editing
essh() {
    if [ $# -eq 0 ]; then
        echo "Usage: essh [user@]hostname [additional_ssh_options]"
        echo "Examples:"
        echo "  essh user@example.com"
        echo "  essh root@192.168.1.100"
        echo "  essh -p 2222 user@example.com"
        return 1
    fi
    
    # Parse arguments to extract host and any SSH options
    local ssh_args=()
    local host=""
    local port=""
    
    # Process arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p)
                port="$2"
                ssh_args+=("$1" "$2")
                shift 2
                ;;
            -*)
                ssh_args+=("$1")
                shift
                ;;
            *)
                if [[ -z "$host" ]]; then
                    host="$1"
                else
                    ssh_args+=("$1")
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$host" ]]; then
        echo "Error: No hostname provided"
        return 1
    fi
    
    # Build the TRAMP path
    local tramp_path="/ssh:"
    
    # Add port if specified
    if [[ -n "$port" ]]; then
        # Extract user and hostname
        if [[ "$host" == *"@"* ]]; then
            local user="${host%@*}"
            local hostname="${host#*@}"
            tramp_path="/ssh:${user}@${hostname}#${port}:"
        else
            tramp_path="/ssh:${host}#${port}:"
        fi
    else
        tramp_path="/ssh:${host}:"
    fi
    
    echo "Opening Emacs with TRAMP connection to: $tramp_path"
    
    # Launch GUI Emacs with TRAMP
    # Use nohup to detach from terminal and redirect output
    nohup emacs "$tramp_path" >/dev/null 2>&1 &
}

# Open remote eshell in Emacs TRAMP with -nw
tramp() {
  if [[ -z "$1" ]]; then
    echo "Usage: tramp user@host [remote-path]"
    return 1
  fi

  local userhost="$1"
  local path="${2:-~}"   # default to home dir if not given

  emacs -nw --eval "(let ((default-directory \"/ssh:${userhost}:${path}/\")) (eshell t))"
}

# Persistent SSH that auto-reconnects and supplies the password once.
# Requires: autossh, sshpass
pssh() {
  if [[ -z "$1" ]]; then
    echo "Usage: pssh user@host [ssh-args...]"
    echo "Examples:"
    echo "  pssh user@server"
    echo "  pssh user@server -p 2222"
    echo "  pssh user@server -L 8080:localhost:80"
    return 1
  fi

  local userhost="$1"
  shift

  # secure password prompt (no echo)
  local pw
  read -rs "pw?Password for ${userhost}: "
  echo

  # Ensure autossh always launches ssh THROUGH sshpass (even on restarts)
  # Using env var avoids showing the password in process args.
  SSHPASS="$pw" AUTOSSH_SSH="sshpass -e ssh" \
  autossh \
    -M 0 \
    -o ServerAliveInterval=30 \
    -o ServerAliveCountMax=3 \
    -o StrictHostKeyChecking=accept-new \
    "$userhost" "$@"

  # cleanup
  unset pw
}
